-:Solidity Notes:-

State Variables - Variables declared outside the functions are called state variables. They are stored on the blockchain.

Local Variables - Variables declared inside the functions are called local variables. They are not stored on the blockchain.

Types of Functions - Create transaction(write data or change the state of the blockchain) cost some gas and Doesn't create transaction(read data from the blockchain - view & pure) are free of cost .

Data location of the variables: we need to specify location for dynamic data types.
(storage, memory and calldata keywords) - 
Memory(data is loaded onto memory) means our input is a value outside of our contract. This is used if we only need to read the data or modify it without saving it on the blockchain. It copies the data in the variable.
Storage(state variable) means our input is a value stored in our contract. This is used to load dynamic data that we will update. It stores the reference to the variable.
Calldata(like memory but are only used for function inputs) - This is used to save gas, if we are using an array as a parameter in a function and we need to pass that array again in another function, then we can use calldata to avoid copying the data in the other array again.

contract DataLocations{
struct MyStruct{
	uint foo;
	string text;
}
mapping(address=>MyStruct) public myStructs;

function examples() external returns(uint[] memory) {
myStructs[msg.sender]=MyStruct({foo:123,text:"bar"});

//here we are getting MyStruct struct from the mapping myStructs that is stored at msg.sender and we are telling here solidity that the variable we are about to use should point back to storage(state variable)

MyStruct storage myStruct=myStructs[msg.sender];
myStruct.text="foo";

MyStruct memory readOnly=myStructs[msg.sender];
readOnly.foo=456;//but this change will not be saved as the data is loaded onto memory, hence will only be valid till function ends

//initialise uint array in memory
uint[] memory memArr=new uint[](5);//can only create fixed sized array
memArr[0]=234;
return memArr;
	}
}

View and Pure - View declares that our function doesn't modify the state of our blockchain whereas Pure declares that our function doesn't modify the state of our blockchain and also doesn't read state variables.

These statements are considered modifying the state(view):
1. Writing to state variables.
2. Emitting events.
3. Creating other contracts.
4. Using selfdestruct.
5. Sending Ether via calls.
6. Calling any function not marked view or pure.
7. Using low-level calls.
8. Using inline assembly that contains certain opcodes.

These statements are considered reading the state(pure):
1. Reading from state variables.
2. Accessing address(this).balance or <address>.balance
3. Accessing any of the members of block, tx, msg(with msg.sig and msg.data as exception).
4. Calling any function not marked pure.
5. Using inline assembly that contains certain opcodes.

Ether, Wei & Gwei - uints in which Ether is 10^18 wei whereas Gwei is 1 billion(10^9) wei.

Transaction fee = Gas used * Gas price.
Gas limit is set by us and Block gas limit is set by the network.
If you run out of gas in the middle of the execution the transaction gets reverted but the gas is still paid.

I/O restrictions for public functions:
In solidity, functions can't take or return multidim-array(unifxed size) or maps, they can take array but it shouldn't be done bcoz of gas that will be used can go very high. Instead use upper bound for the number of elements the array can have like use fixed size array.

//Another way to return multiple values
function f() public pure returns(uint x, bool a, uint y) {
x=1;
b=true;
y= 3;
}

//Destructuring arguments
(uint i, bool b, uint j)=returnMultiVlaues();
//values can be left out
(uint x, , uint y) = (4,5,6);
// outputs can be grouped like this
return (i, b, j, y, x);

//Reentrancy is like recursion
bool locked;
modifier noReentrancy() {
require(!locked, "Locked");
_; //This underscore asks solidity to continue the function for which the modifier is used
locked=true;
_;
locked=false;
}

//For overriding functions in parent contract using inheritance both should have same signature that is same arguments
//passing parameters to the parent constructor
1. contract B is A("Contract B"){}
2. contract B is A {
constructor() A("Contract B") 
}
//passing variable parameter to parent constructor
contract B is A {
constructor(string memory _name) A(_name) {}
}
//passing variable parameters to multiple parent constructors
//parent constructors are called in the order in which they are inherited like here first X then Y not in the order in which they are called
contract D is X, Y { //contracts X & Y will have different state variables name & text
constructor(string memory _name, string memory _text) X(_name) Y(_text) {}

//Inheritance in solidity
contract B is A {}
Solidity uses depth first search(from right to left) in multiple-inheritance to find a over-ridden function.
Also in multiple inheritance contracts should be kept in the order from the most base-like to the most derive-like.
contract X{}
contract Y{}
contract Z is X, Y{ //most base-like to derived-like
 function foo() public override(X,Y) {}
} 

The functions that will be inherited will have keyword virtual in parent contract and keyword override in child contract. 
In case of three levels of inheritance:
parent contract     - virtual
child contract      - virtual override
grandchild contract - override

//Events
//event created 
event Log(string message);
//event fired
function foo() public{
emit Log("A.foo was called");
}

//we can call functions in parent contract using parent contract object in child contract
//using keyword super to call the function in parent contract will automatically call all the parent contracts

//over-riding state variables of the parent contract in child contract
//never override directly by redeclaring in the child contract as solidity will give no warnings but the override will not take place instead do overriding inside child contract constructor by reassigning

//Visiblity of state variables and functions
Private - only accessible from inside the contract not from child contract(use public functions to expose the private functions and variables
Internal - accessible inside itself and child contract
Public - accessible by any contract and any account
External(invalid for state variable, only valid for functions) - can only be called by other contracts and accounts but not inside the same contract in which it is declared

//Events
contract Event {
//by using keyword indexed we can search for specific events like here we can search for all log events by a sender by using his address, we can only set 3 parameters indexed at max
event Log(address indexed sender, string message);
event AnotherLog();

function fireEvents() public {
// emit keyword fires the event and logs the event 
emit Log(msg.sender, "Hello world"); //this will log the address of the caller and hello world string
emit Log(msg.sender, "Hello EVM");
emit AnotherLog();
//now go and check the transaction log and find logs section you will have all the results
//these logs will be stored on the blockchain and smart contracts will be able to access these logs, one use case of firing events is to record that something happened on the blockchain and it is cheaper than storing data on a smart contract


// msg.sender gives the address of the sender of the transaction

//Errors (when a func throws an error it will revert all the state updates that were made in the current call, gas is refunded)
assert(checks for desired result after the process) - this will check for something is true or not, when assertion fails it will use all of the gas that u send and state changes will be undone.
require(validating inputs and access control) - validation occurs before execution, will not use all of the gas.
revert - same as require but is useful for complex conditions.

//overflow(it occurs when a number goes beyond 2^256) opposite is underflow
if x+y >= x, then no overflow(the sum didn't cross 2^256)
if x+y < x, then overflow occurred(the sum crossed 2^256 and started from the begining)

//Array
uint[] public arr;
to keep array compact means to move last element into the index whose element has been deleted

Use keyword `delete` to set that index or value to 0, it doesn't actually delete.

//Mapping (key => value)
we can't iterate through a mapping, for that use array with mapping
mapping(address => uint[]) public myMap;
mapping gives value 0 for keys that don't have any value

mapping(address=>mapping(address=>bool)) public isFriend;
isFirend[msg.sender][address(this)]=true;

//bytes32 is used to store hashes

//enum 
enum Status{
	Pending,
	Shipped,
	Accepted,
	Rejected,
	Canceled
}

Status public status;

function ship() public {
	require(status==Status.Pending);
	status=Status.Shipped;
}

function acceptDelivery() public {
	require(status==Status.Shipped);
	status=Status.Accepted;
}

The default value of enum type is always it's first element in the definition i.e. Pending in this case.
The results come in the uint like for Pending it will give 0, 1 for Shipped, 3 for Accepted, 4 for Rejected and 5 for Canceled.

//Structs
struct Todo {
	string text;
	bool completed;
}

Todo[] public todos;

Initializing a struct
function create(string memory _text) public {
	//first way(push is for todo array)
	todos.push(Todo(_text, false));
	//second way
	Todo({text: _text, completed: false})
	//third way
	Todo memory todo;
	todo.text = _text;
	//false is the default value for bool
	//fourth way
	Todo("Prakash", true);
}

Returning a struct
function get(uint _index) public view returns(string memory, bool) {
	Todo storage todo = todos[_index];
	return (todo.text, todo.completed);
}

function update(uint _index, string _text) public {
	Todo storage todo = todos[_index];
	todo.text = _text;
}
function toggleCompleted(uint _index) public {
	Todo storage todo = todos[_index];
	todo.complete = !todo.complete;
}

//Payable
If you are building UI on top of a contract then emitting the events is essential if you want to get your updates in real-time.

contract Wallet {
event Deposit(address sender, uint amount, uint balance);
event Withdraw(uint amount, uint balance);
event Transfer(address to, uint amount, uint balance);

address payable public owner;

constructor() payable { //this will make smart contract have some ether while deploying
	owner=msg.sender;
}

function deposit() public payable {
emit Deposit(msg.sender, msg.value, address(this).balance);
}

modifier onlyOwner() {
	require(msg.sender == owner, "not owner");
	_;
}

function withdraw(uint _amount) public onlyOwner {
owner.transfer(_amount);
emit Withdraw(_amount, address(this).balance);
}

function transferEther(address payable _to, uint _amount) public onlyOwner {
_to.transfer(_amount);
emit Transfer(_to, _amount, address(this).balance);
}

function getBalance() public view returns(uint) {
	return address(this).balance;
}

}


//3 ways to send ether from one contract to another
//if a contract receives ether from any of these functions(send, transfer, call) there is another function(inside the receiving contract) that is triggered and that's Fallback function
- transfer (forwards 2300 gas, throws error)
- send (forwards 2300 gas, returns bool)
- call (forward all gas or set gas, returns bool and data)
*call is recommended to guard against re-entrancy hack.

contract ReceiveEther {
//fallback function - it can't take input, can't return outputs, must be external, must be payable.

fallback() external payable{}

//helps in receiving ether when the contract is deployed
constructor() external payable{} 

function getBalance() public view returns(uint) {
	returns address(this).balance;
	}
}

contract sendEther {
function sendViaTransfer(address payable _to) public payable {
	_to.transfer(msg.value);
	}

function sendViaSend(address payable _to) public payable {
//since send method returns bool we use variable to capture it
	bool sent = _to.send(msg.value);
	require(sent,"Failed to send ether");
}
function sendViaCall(address payable _to) public payable {

//since call method returns bool and second part of the ouput holds the returned values of fallback function, since fallback function can't return any values it will hold 0 bytes

(bool sent, bytes memory data) = _to.call{value:msg.value}("");
//to specify how much gas you want to send you can use .gas(1000) after 

require(sent, "Failed to send Ether");
}

}


//Fallback function

contract Fallback {
event Log(uint gas);

//this is fallback function
fallback() external payable{ 

//we can write code here but it is recommended that we don't write any code here because if we send ether via send/transfer it forwards 2300gas to this fallback function which is enough to emit a log but not enough gas to write to storage or call another contract.

//send/transfer(forwards 2300 gas to this fallback function)
//call(forwards all of the gas)
	emit Log(gasleft());
	}
}

contract SendToFallback {
function transferToFallback(address payable _to) public payable {
	_to.transfer(msg.value);
	}

function callFallback(address payable _to) public payable {
(bool sent,) = _to.call{value:msg.value}("");
require(sent, "Failed to send the ether");
	}
}

//call method - It's a low level method that's available on all address types
//examples - To call existing function and call non-existing function(triggers the fallback function)
*this is not the recommended way to interact with functions 

contract Receiver {
//here event will help in tracking code execution
Event Received(address caller, uint amount, string message);

function() external payable{
emit Received(msg.sender,msg.value,"Fallback called");
}

function foo(string memory _message, uint _x) public payable returns(uint) {
emit Received(msg.sender,msg.value,_message);
returns _x+1; //this returned value will be in hexadecimal so parseInt() it.
	} 
}

//to call a function from another contract
contract Caller{
event Response(bool success, bytes data);

function testCallFoo(address payable _addr) public payable{

//(leave the double quotes of function empty to call Fallback)
//the value and gas specification is used to sets the amount of ether and gas we want to send

(bool sent, bytes memory data) = _addr.call{value:msg.value, gas:5000}(abi.encodeWithSignature("foo(string,uint256)", "call foo", 123));

//we write function signature with no space in between while writing the argument types and then we use uint256 as uint is the alias of uint256, next parameters will be the actual inputs we want to send in the arguments

emit Response(success, data);
	}

function testCallDoesNotExist(address _addr) public {

//here the function doesNotExist() does not exist so it will trigger Fallback function
(bool sent, bytes memory data) = _addr.call(abi.encodeWithSignature("doesNotExist()"));

emit Response(success, data);
	}
}


//delegatecall function - A low level function similar to call which calls a function of different contract on behalf of the contract in which it exists. 

Tom ----> contract A -------> contract B
inc()     uint x;             uint x; 
1 eth     func inc(){         func inc(){
             B.delegatecall       x+=1;
           }                   }

Output:   msg.sender=Tom      msg.sender=Tom
          msg.value=1eth      msg.value=1eth
          x=1;                x=0;

contract B{//these state variables should be in same order as contract A
	uint public num;
	address public sender;
	uint public value;

function setVar(uint _num) public payable{
	num = _num;
	sender = msg.sender;
	value = msg.value;
	}
}

contract A{
	uint public num;
	address public sender;
	uint public value;

function setVar(address _contract, uint _num) public payable {
(bool success, bytes memory data) = _contract.delegatecall(abi.encodeWithSignature("setVar(uint256)", _num));
	}
}

//calling functions in other contracts using their own address contract.func()
//The advantage of calling a function like this is if the function doesn't exist solidity will not compile

contract Callee {
	uint public x;
	uint public value;

function setX(uint _x) public returns (uint){
	x = _x;
	return x;
}

function setXandSendEther(uint _x) public payable returns(uint, uint) {
	x = _x;
	value = msg.value;
	return (x, value);
	}
}

contract Caller {
//in the argument we use name & address of the contract whose function we want to call
//here we are passing the contract directly
function setX(Callee _callee,uint _x) public{
_callee.setX(_x);

//another way of doing the same thing is
//function setX(address _addr,uint _x)public{
//Callee callee = Callee(_addr);//instantiate the contract at the address
uint x = callee.setX(_x);
//}
}

function setXandSendEther(Callee _callee, uint _x) public payable {
(uint x, uint value) = _callee.setXandSendEther.value(msg.value)(_x)
	}
}

//creating contracts from a contract
contract Car {
string public model;
address public owner;

constructor(string memory _model, address _owner) payable {
	model = _model;
	owner = _owner;
	}

}

contract CarFactory {
//to keep track of individual contract
Car[] public cars;

function create(string memory _model) public { //we use keyword new to create a contract inside another contract
Car car = new Car(_model, address(this));
cars.push(car);
	}

//to get a car model after creation, input it's index, copy the contract address from the result, do to deploy & run transactions select the car contract then paste the address, then click on At Address. You will get that car contract below, click on model and check it.

function createAndSendEther(string memory _model, address _owner) public payable{
Car[] public cars;
Car car = new Car{value:msg.value}(_model, msg.sender)
cars.push(car);
	}
}

//import 
-local files
import "./RELATIVE_PATH/NAME";

-github (for remix only)
import "PASTE_THE_URL_THEN_REMOVE_https://";
->Always compare the version, if older needed switch to older branches

contract MyContract is THE_IMPORTED_CONTRACT {}


//libraries
- no storage, no gas
- helps keep your code DRY(Don't Repeat Yourself)

It is of two types:
- embedded into the contract during compilation (library has only internal functions)
- must be deployed and then linked (library has public or external functions)

library SafeMath {//embedded library
function add(uint x, uint y) internal pure returns(uint) {

uint z = x+y;
require(z>=x, "uint overflow");

return z;
}

contract TestSafeMath {

//using A for B means attach all functionalities from library A to data-type B
using SafeMath for uint;//for implicit type parameter passing, because of this we can call function on that data type directly

//since solidity doesn't have INT_MAX
uint public MAX_UINT = 2 ** 256 -1;
//** means to the power

function testAdd(uint x, uint y) public pure (returns uint){
return x.add(y);//implicitly passing the parameter
}

//SafeMath.add(x,456);//explicitly passing

}

library Array {//deployed or linked library
function remove(uint index) public {
arr[index] = arr[arr.length-1];
arr.pop();
	}
}

contract TestArray {
using Array for uint[];

uint[] public arr;

function testingArrayRemove() public {
	for(uint i=0; i<3; i++){
		arr.push(i);
	}//[0,1,2]
}
arr.remove(1);//[0,2]

//checks
assert(arr.length==2);
assert(arr[0]==0);
assert(arr[1]==2);
}

//creating array in memory
uint[] memory arr = new uint[](5);
we can't call push and pop for array created in memory.

//hashing function (keccak 256)
//abi.encodePacked() takes any type and amount of data and gives bytes32 type of it
//keccak256() takes bytes32 as input and gives 32 byte hash of it

bytes32 hash = keccak256(abi.encodePacked("hello", uint(1), address(123))); 

function hashed(string memory _text, uint _num, address _addr) public pure returns (bytes32) {
	return keccak256(abi.encodePacked(_text, _num, _addr));
}

// AAA BBB -> AAABBB
// AA ABBB -> AAABBB
//we create collision using more than one dyanamic data type by using abi.encodePacked() in that case use abi.encode()



//Signature Verification
#Signing
1. Create message to sign
2. Hash the message
3. Sign the hash(off chain, keep your private key secret)

#Verify
1. Recreate hash from the original message
2. Recover signer from signature and hash
3. Compare recovered signer to claimed signer

contract VerifySignature {
function getMessageHash(address _to, uint _amount, string memory _message, uint _nonce) public pure returns (bytes32) {
	return keccak256(abi.encodePacked(_to, _amount, _message, _nonce));
}

Signature is produced by signing a keccak256 hash with the following format:
"\x19Ethereum Signed Message\n" + len(msg) + msg
this becomes:
keccak256(\x19Ethereum Signed Message\n32...msg hash here...)

function getEthSignedMessage(bytes32 _messageHash) public pure returns(bytes32){
	returns keccak256(abi.encodePacked("\xEthereum Signed Message:\n32", _messageHash));
}

//function verify() public {
//watch and write if needed
}
}

//interface-interact with other smartcontract
contract Counter{//this contract will be used by another contract
uint public count;
function increment() external;
}

interface ICounter{
function count() external view returns(uint);
function increment() external; 
}

contract MyContract{

//the address of the contract(whose functionalities are to be used -in this case Counter) is passed as parameter in the interface which helps in implementing it and interacting using it

function incrementCounter(address _counter) external{
	ICounter(_counter).increment();
}

function getCount(address _counter) external view
returns (uint){
	return ICounter(_counter).count();
	}

}

//solidity ^0.8;
safe math - this version doesn't support overflow and underflow and it will throw an error.
By wrapping the overflowing or underflowing statement in unchecked we can do this like - unchecked{x--;}

custom error - this means we can define a custom error function and use it using revert function. We can define it outside the contract also, this will help in importing it inside other contracts.
like - error Unauthorized(address caller);
revert Unauthorized(msg.sender);

functions (outside the contract) - Just dont use state variables from the contract and don't address the contract from the outside using address(this).
function helper() view returns (uint) {}

//importing the custom errors and functions outside the contracts using import statement
import { Unauthorized, helper } from "./Sol.sol";
if we want to use same name of a helper then we can use alias like - helper as help1

//create2 got new keyword and we don't need to use assembly
//create2 helps in creating and deploying a contract

//INT_MAX and INT_MIN in solidity
int public minInt = type(int).min;
uint public maxInt = type(uint).max;

//bytes32 data type
bytes32 public b32 = 0x67654531sfdf68567;


//todo list
contract Todo{
struct Todo{
	string text;
	bool completed;
	}
Todo[] public todos;

function create(string calldata _text) external{
	todos.push(Todo({text: _text, 
		completed: false}));
}
function updateText(uint index,string calldata _text) external{
//1st way
//35138 gas as we are accessing the array 3 times here, so this is suitable when we are updating the array only once
todos[index].text=_text;
todos[index].text=_text;
todos[index].text=_text;

//2nd way
//34578 gas coz here we are accessing the array only once and referencing at the that once
Todo storage todo=todos[_index];
todo.text=_text;
todo.text=_text;
todo.text=_text;
}

function get(uint _index) external view returns(string memory, bool){
//here memory uses 29480 gas and storage uses 29397 
Todo memory todo=todos[_index];
return (todo.text, todo.completed);
}

function toggleComplete(uint _index) external{
	todos[_index].completed=!todos[_index].completed;
	}
}

//Immutable - Variables that are declared immutable can only be intialised when the contract is deployed after that they can't be updated. It also saves some gas.
contract Example{
address public immutable owner;
constructor(){
onwer=msg.sender;
	}
}

//payable
contract Example{

address payable public owner;

constructor() {
//here we are type-casting msg.sender as payable
owner=payable(msg.sender); 
	}

//this function will receive ether as it has keyword payable
function deposit() external payable{}

function getBalance() external public view returns(uint){
	return address(this).balance;
	}
}


